<script src="https://cdn.jsdelivr.net/npm/phaser@3.15.1/dist/phaser-arcade-physics.min.js"></script>
<script>

var config = {
    width: 1200,
    height: 500,
    type: Phaser.AUTO,
    scene: {
        preload: preload,
        create: create,
        update: update
    },
    backgroundColor: '#FFFFFF',
    pixelArt: false // Enable texture smoothing
};

var bgConfig = {
    scale: 1,
    x: 0,
    y: 0,
    originX: 0,
    originY: 0
};

var sliderConfig = {
    handle: {
        scale: 0.25,
        originX: 0.5,
        originY: 0.5,
        slideLeftX: 119,
        slideRightX: 387
    },
    sliders: {
        angleOfIncidenceHandle: { // degrees
            y: 360,
            minVal: 30,
            maxVal: 60,
            startVal: 40
        },
        refractiveIndexHandle: {
            y: 443,
            minVal: 1,
            maxVal: 2.5,
            startVal: 2
        }     
    },
    track: {
        lineThickness: 4,
        lineTint: '0xFFA218' //orange
    }
};

const raysConfig = {
    lineTint: '0xF650DA', //bright pink
    lineThickness: 3,
    lengthInSquares: 5,
    arrow: {
        image: 'arrowPink-img',
        originX: 0.5,
        originY: 0.5
    }
}

const geometryConfig = { //some of these are used by the code - some for description - order shows how to construct
    originX: 1, // in squares from left of grid
    labelSpacing: 0, //pixels from item labelled
    dots: {
        line: 10, // pixels
        gap: 5 // pixels
    },
    incomingWavefront: {
        line: {
            thickness: 6,
            tint: '0xFFA218', //orange
            startPoint: 'A',
            endPoint: 'B',
            arrow: 'none',
            style: 'solid'

        },
        orientation: {
            angle: 'i',
            reference: 'horizontal',
            sense: 'ccw',
            length: 3 // arbitrarily set
        },
        labelImage: 'none'
    },
    commonHypoteneus: {
        line: {
            thickness: 4,
            tint: '0xA6CAEC', //pale blue
            startPoint: 'A',
            endPoint: 'C',
            arrow: 'none',
            style: 'dotted',
        },
        orientation: {
            angle: '0',
            reference: 'horizontal',
            sense: 'na',
            length: 'calculated' // = AB / cos i
        },
        labelImage: {
            name: 'hText-img',
            originX: 0.5,
            originY: 0.75,
            position: 'middle'
        }
    },
    rightMainRay: {
        line: {
            thickness: 6,
            tint: '0xF650DA', //bright pink
            startPoint: 'B',
            endPoint: 'C',
            arrow: 'none',
            style: 'solid',
        },
        orientation: {
            angle: 'na',
            reference: 'na',
            sense: 'na',
            length: 'calculated' // from B to C
        },
        labelImage: {
            name: 'tEqualsHsiniOverCText-img',
            originX: 0.18,
            originY: 0.5,
            position: 'right'
        }
    },
    outgoingWavefront: {
        line: {
            thickness: 6,
            tint: '0xFFA218', //orange
            startPoint: 'C',
            endPoint: 'D',
            arrow: 'none',
            style: 'solid'
 
        },
        orientation: {
            angle: 'r',
            reference: 'horizontal',
            sense: 'ccw',
            length: 'calculated' // = AC cos r
        },
           labelImage: 'none'              
    },
    leftMainRay: {
        line: {
            thickness: 6,
            tint: '0xF650DA', //bright pink
            startPoint: 'D',
            endPoint: 'A',
            arrow: 'none',
            style: 'solid',
            labelImage: 'none'
        },
        orientation: {
            angle: 'na',
            reference: 'na',
            sense: 'na',
            length: 'calculated' // from D to A
        },
        labelImage: {
            name: 'tEqualsHsiniOverCOverNText-img',
            originX: 0.95,
            originY: 0.5,
            position: 'left'
        }
    },
    rightMainRayUp: {
        line: {
            thickness: 3,
            tint: '0xF650DA', //bright pink
            startPoint: 'B',
            endPoint: 'BUp',
            arrow: 'arrowPink-img',
            style: 'dotted',
        },
        orientation: {
            angle: 'i',
            reference: 'vertical',
            sense: 'ccw',
            length: 1.5 // squares
        },
        labelImage: 'none'
    },
    leftMainRayUp: {
        line: {
            thickness: 3,
            tint: '0xF650DA', //bright pink
            startPoint: 'A',
            endPoint: 'AUp',
            arrow: 'arrowPink-img',
            style: 'dotted',
        },
        orientation: {
            angle: 'i',
            reference: 'vertical',
            sense: 'ccw',
            length: 1 // squares
        },
        labelImage: 'none'
    },
    rightMainRayDown: {
        line: {
            thickness: 3,
            tint: '0xF650DA', //bright pink
            startPoint: 'C',
            endPoint: 'CDown',
            arrow: 'arrowPink-img',
            style: 'dotted',
        },
        orientation: {
            angle: 'r',
            reference: 'vertical',
            sense: 'cw',
            length: 3.5 // squares
        },
        labelImage: 'none'
    },
    leftMainRayDown: {
        line: {
            thickness: 3,
            tint: '0xF650DA', //bright pink
            startPoint: 'D',
            endPoint: 'DDown',
            arrow: 'arrowPink-img',
            style: 'dotted',
        },
        orientation: {
            angle: 'r',
            reference: 'vertical',
            sense: 'cw',
            length: 2 // squares
        },
        labelImage: 'none'
    },
    normal: {
        line: {
            thickness: 2,
            tint: '0x983A7F', //dull purple
            throughPoint: 'C',
            style: 'dotted'
        },
        orientation: {
            reference: 'vertical',
            length: 6, // squares
            startSquaresDown: 1 // squares from top
        },
        labelImage: 'none'
    }
}

const uiConfig = {
    playControls: {
        depth: 500,
        playPause: {
            x: 620, //
            y: 57, // was 140
            originX: 0.5,
            originY: 0.5            
        },
        reset: {
            x: 390,  //
            y: 120,  // was 200
            originX: 0.5,
            originY: 0.5        
        }
    }
}

let switchConfig = {
    scale: 1,
    x: 610,
    originX: 0,
    originY: 0.5,
    xNudge: 0,
    yNudge: 0,
    font: 'Calibri',
    textSize: 16,
    textTint: '#FFFFFF',
    textPositionLeftOfSwitch: 10,
    i: {
        y: 380,
        words: 'i value',
        startState: 'off'
    },
    r: {
        y: 410,
        words: 'r value',
        startState: 'off'
    }
};

const visualizationConfig = {
    grid: {
        topLeftX: 689,
        topLeftY: 42,
        bottomRightX: 1151,
        bottomRightY: 451,
        squaresAcross: 9,
        squaresDown: 8
    },
    normal: {
        squaresAcross: 5,
        startSquaresDown: 1,
        lengthInSquares: 6
    },
    waves: {
        display: {
            lineTint: '0xFFA218', //orange
            lineThickness: 3           
        },
        lengthInSquares: 3,
        pixelVelocityIncrementPerTickVacuum: 1,
        gridVelocityVacuum: 2, // squares per "second"
        period: 1 // in "seconds" - used to calculate when to spawn the next wave
    },
    medium: {
        mediumBoundary: 0.5, // fraction down grid
        mediumTint: '0x00B0F0',
        minAlpha: 0,
        maxAlpha: 0.5
    }
}

const radioButtonGroups = { // labels for radio buttons are in background image so ref value to make debugging easier
    scale: 1,
    x: 645,
    originX: 0.5,
    originY: 0.5,
    verticalSpacing: 37,
    group1: {
        name: 'visualizationChoice',
        startY: 154,
        selected: 'button1',
        button1: {
            ref: 'ray'
        },
        button2: {
            ref: 'wavefront'
        },
        button3: {
            ref: 'geometry'
        }        
    }
};

const anglesConfig = {
    line: {
        thickness: 2,
        brightTint: '0xFFFFFF', // white
        dullTint: '0x983A7F', //dull purple
    },
    arc: {
        radius: 60 // pixels
    },
    rightAngle: {
        length: 20 // pixels
    },
    label: {
        originX: 0.5,
        originY: 0.5,
        fractionOfRadius: 0.7
    },
    valueDisplay: {
        font: 'Calibri',
        textSize: 18,
        tint: '#FFFFFF' // white    
    }
}

let info = {
    incidentRay: {
        startX: null,
        startY: null,
        endX: null,
        endY: null,
        speed: null //in pixels per tick
    },
    refractedRay: {
        startX: null,
        startY: null,
        endX: null,
        endY: null,
        speed: null //in pixels per tick        
    },
    mediumBoundaryScreenY: null,
    wavefrontPointsReference: { // 'incident ray', 'refracted ray', 'boundary' (float only)
        lowerLeft: 'incident ray',
        float: 'incident ray',
        upperRight: 'incident ray'
    },
    geometry: {
        A: {
            x: null,
            y: null
        },
        B: {
            x: null,
            y: null
        },
        C: {
            x: null,
            y: null
        },
        D: {
            x: null,
            y: null
        }
    }
}

let values = {
    i: sliderConfig.sliders.angleOfIncidenceHandle.startVal, // angle of incidence in degrees
    r: null, // angle of refraction in degrees
    n: sliderConfig.sliders.refractiveIndexHandle.startVal
};

let showValues = {
    i: switchConfig.i.startState === 'on',
    r: switchConfig.r.startState === 'on'
}

const valueKeysMapping = {
    'refractiveIndexHandle': 'n',
    'angleOfIncidenceHandle': 'i'  
};

let game = new Phaser.Game(config);
let sliders = [];
let playing = true;

let visualization;
let ui;
let rays;
let wavefronts;
let geometry;
let angles;

let rayBackground;
let wavefrontBackground;
let geometryBackground;

class Test {
    constructor(scene, x, y) {
        this.scene = scene;
        this.x = x;
        this.y = y;
        this.handle = null;
    }

    create() {

        // Create the handle image with 50% alpha
        this.handle = this.scene.add.image(this.x, this.y, 'handle');
        this.handle.setAlpha(0.5);
        this.handle.setScale(0.2); // Scale the handle to 20%
        this.handle.setInteractive({ useHandCursor: true });

        // Make the handle draggable
        this.scene.input.setDraggable(this.handle);

        // Output the coordinates to the console when dragging
        this.handle.on('drag', (pointer, dragX, dragY) => {
            this.handle.setPosition(dragX, dragY);
            console.log(`x: ${dragX}, y: ${dragY}`);
        });
    }
}

class Wavefronts {
    constructor(scene) {
        this.scene = scene;
        this.waves = [];
        this.ticksSinceLastWave = 0;
        this.endOfRayReached = false;

        const gridConfig = visualizationConfig.grid;
        this.cartesianOrigin = {
            x: gridConfig.topLeftX, 
            y: gridConfig.bottomRightY 
        };
    }

    // Convert from screen to Cartesian coordinates
    screenToCartesian(x, y) {
        const { x: originX, y: originY } = this.cartesianOrigin;
        return { x: x - originX, y: originY - y };
    }

    // Convert from Cartesian to screen coordinates
    cartesianToScreen(x, y) {
        const { x: originX, y: originY } = this.cartesianOrigin;
        return { x: x + originX, y: originY - y };
    }

    // Calculate the gradient of a ray
    calculateRayGradient(startX, startY, endX, endY) {
        const startCartesian = this.screenToCartesian(startX, startY);
        const endCartesian = this.screenToCartesian(endX, endY);
        return (endCartesian.y - startCartesian.y) / (endCartesian.x - startCartesian.x);
    }

    // Calculate perpendicular gradient to a ray
    calculatePerpendicularGradient(rayGradient) {
        return -1 / rayGradient;
    }

    // Calculate velocity in the second medium using Snell's Law
    calculateRefractedVelocity(incidentVelocity) {
        const n1 = 1; // Air refractive index
        const n2 = values.n; // Medium refractive index

        let refractedVelocity = incidentVelocity * (n1 / n2);

        info.incidentRay.speed = incidentVelocity;
        info.refractedRay.speed = refractedVelocity;

        return refractedVelocity;
    }

    drawGrowingRay() {
        // Ensure this method is only called while the ray is growing
        if (this.endOfRayReached) return;

        const { startX: incidentStartX, startY: incidentStartY, endX: incidentEndX, endY: incidentEndY } = info.incidentRay;
        const { startX: refractedStartX, startY: refractedStartY, endX: refractedEndX, endY: refractedEndY } = info.refractedRay;

        // Ray configuration
        const config = raysConfig;

        // Calculate dx and dy for incident ray growth
        const incidentDx = (incidentEndX - incidentStartX) / Phaser.Math.Distance.Between(incidentStartX, incidentStartY, incidentEndX, incidentEndY);
        const incidentDy = (incidentEndY - incidentStartY) / Phaser.Math.Distance.Between(incidentStartX, incidentStartY, incidentEndX, incidentEndY);

        // Incrementally grow the ray
        if (!this.refractedRayStarted) {
            // Grow the incident ray
            this.currentIncidentX = this.currentIncidentX || incidentStartX;
            this.currentIncidentY = this.currentIncidentY || incidentStartY;

            this.currentIncidentX += incidentDx * info.incidentRay.speed;
            this.currentIncidentY += incidentDy * info.incidentRay.speed;

            // Check if the incident ray has reached the end point
            if (Phaser.Math.Distance.Between(this.currentIncidentX, this.currentIncidentY, incidentEndX, incidentEndY) <= info.incidentRay.speed) {
                this.currentIncidentX = incidentEndX;
                this.currentIncidentY = incidentEndY;
                this.refractedRayStarted = true; // Start growing the refracted ray
            }

            // Draw the incident ray
            this.drawRay(incidentStartX, incidentStartY, this.currentIncidentX, this.currentIncidentY, config.lineTint, config.lineThickness, 'incident');
        } else {
            // Grow the refracted ray
            const refractedDx = (refractedEndX - refractedStartX) / Phaser.Math.Distance.Between(refractedStartX, refractedStartY, refractedEndX, refractedEndY);
            const refractedDy = (refractedEndY - refractedStartY) / Phaser.Math.Distance.Between(refractedStartX, refractedStartY, refractedEndX, refractedEndY);

            this.currentRefractedX = this.currentRefractedX || refractedStartX;
            this.currentRefractedY = this.currentRefractedY || refractedStartY;

            this.currentRefractedX += refractedDx * info.refractedRay.speed;
            this.currentRefractedY += refractedDy * info.refractedRay.speed;

            // Check if the refracted ray has reached the end point
            if (Phaser.Math.Distance.Between(this.currentRefractedX, this.currentRefractedY, refractedEndX, refractedEndY) <= info.refractedRay.speed) {
                this.currentRefractedX = refractedEndX;
                this.currentRefractedY = refractedEndY;
                this.endOfRayReached = true;
            }

            // Draw the refracted ray
            this.drawRay(refractedStartX, refractedStartY, this.currentRefractedX, this.currentRefractedY, config.lineTint, config.lineThickness, 'refracted');
        }
    }

    // Helper function to draw the ray and update the arrow position/rotation
    drawRay(startX, startY, currentX, currentY, tint, thickness, rayType) {
        // Clear existing ray graphics
        if (!this[`${rayType}RayGraphics`]) {
            this[`${rayType}RayGraphics`] = this.scene.add.graphics();
        }
        this[`${rayType}RayGraphics`].clear();

        // Draw the growing ray
        this[`${rayType}RayGraphics`].lineStyle(thickness, tint);
        this[`${rayType}RayGraphics`].beginPath();
        this[`${rayType}RayGraphics`].moveTo(startX, startY);
        this[`${rayType}RayGraphics`].lineTo(currentX, currentY);
        this[`${rayType}RayGraphics`].strokePath();

        // Calculate midpoint for arrow
        const midX = (startX + currentX) / 2;
        const midY = (startY + currentY) / 2;

        // Ray configuration
        const config = raysConfig;

        // Create the arrow if it doesn't exist
        if (!this[`${rayType}Arrow`]) {
            this[`${rayType}Arrow`] = this.scene.add.image(midX, midY, config.arrow.image);
            this[`${rayType}Arrow`].setOrigin(config.arrow.originX, config.arrow.originY);
        }

        // Update the arrow's position and rotation
        this[`${rayType}Arrow`].setPosition(midX, midY);
        const angle = Phaser.Math.Angle.Between(startX, startY, currentX, currentY);
        this[`${rayType}Arrow`].setRotation(angle + Phaser.Math.PI2 / 4);
    }

    // Spawn a new wavefront
    spawnWave() {
        const waveConfig = visualizationConfig.waves;
        const waveLength = waveConfig.lengthInSquares * 
            (visualizationConfig.grid.bottomRightY - visualizationConfig.grid.topLeftY) / 
            visualizationConfig.grid.squaresDown;

        const { startX, startY, endX, endY } = info.incidentRay;
        const incidentRayGradient = this.calculateRayGradient(startX, startY, endX, endY);
        const perpendicularGradient = this.calculatePerpendicularGradient(incidentRayGradient);

        // Perpendicular offsets for wavefront
        const dx = Math.sqrt(1 / (1 + perpendicularGradient ** 2)) * waveLength / 2;
        const dy = perpendicularGradient * dx;

        const startCartesian = this.screenToCartesian(startX, startY);
        const startWavefrontLowerLeft = { x: startCartesian.x - dx, y: startCartesian.y - dy };
        const startWavefrontUpperRight = { x: startCartesian.x + dx, y: startCartesian.y + dy };

        const refractedVelocity = this.calculateRefractedVelocity(waveConfig.pixelVelocityIncrementPerTickVacuum);

        const waveData = {
            lowerLeft: { position: startWavefrontLowerLeft, gradient: incidentRayGradient, velocity: waveConfig.pixelVelocityIncrementPerTickVacuum },
            upperRight: { position: startWavefrontUpperRight, gradient: incidentRayGradient, velocity: waveConfig.pixelVelocityIncrementPerTickVacuum },
            float: { position: startCartesian, gradient: incidentRayGradient, velocity: waveConfig.pixelVelocityIncrementPerTickVacuum },
            refractedRayGradient: this.calculateRayGradient(info.refractedRay.startX, info.refractedRay.startY, info.refractedRay.endX, info.refractedRay.endY),
            refractedVelocity,
            line: null
        };

        this.waves.push(waveData);

        info.wavefrontPointsReference = {
            lowerLeft: 'incident ray',
            float: 'incident ray',
            upperRight: 'incident ray'
        };
    }

    // Calculate where the perpendicular line from lowerLeft crosses the boundary
    calculateFloatPositionOnBoundary(lowerLeft, wave, boundaryY) {
        const gradientRefractedRay = wave.refractedRayGradient;
        // Calculate the x-coordinate using the perpendicular to the refracted ray
        const xShift = gradientRefractedRay * (lowerLeft.y - boundaryY); 
        return lowerLeft.x + xShift; // Return the x position of the float
    }

    setPointReferences(wave, boundaryY) {
        const lowerLeft = wave.lowerLeft.position;
        const upperRight = wave.upperRight.position;

        // Assign statuses based on Y position relative to the boundary
        if (lowerLeft.y > boundaryY) {
            info.wavefrontPointsReference.lowerLeft = 'above';
        } else {
            info.wavefrontPointsReference.lowerLeft = 'below';
        }

        if (upperRight.y > boundaryY) {
            info.wavefrontPointsReference.upperRight = 'above';
        } else {
            info.wavefrontPointsReference.upperRight = 'below';
        }

        this.updatePointReferences(wave, boundaryY);
    }

    updatePointReferences(wave, boundaryY) {
        const lowerStatus = info.wavefrontPointsReference.lowerLeft;
        const upperStatus = info.wavefrontPointsReference.upperRight;

        // Case 1: Lower and Upper both above the boundary
        if (lowerStatus === 'above' && upperStatus === 'above') {
            info.wavefrontPointsReference.lowerLeft = 'incident ray';
            info.wavefrontPointsReference.float = 'incident ray';
            info.wavefrontPointsReference.upperRight = 'incident ray';
        }
        // Case 2: Lower is below and Upper is above the boundary
        else if (lowerStatus === 'below' && upperStatus === 'above') {
            info.wavefrontPointsReference.lowerLeft = 'refracted ray';
            info.wavefrontPointsReference.float = 'boundary';
            info.wavefrontPointsReference.upperRight = 'incident ray';
        }
        // Case 3: Both Lower and Upper below the boundary
        else if (lowerStatus === 'below' && upperStatus === 'below') {
            info.wavefrontPointsReference.lowerLeft = 'refracted ray';
            info.wavefrontPointsReference.float = 'refracted ray';
            info.wavefrontPointsReference.upperRight = 'refracted ray';
        }
    }

    updatePoints(wave) {
        const boundaryY = this.screenToCartesian(0, info.mediumBoundaryScreenY).y;

        ['lowerLeft', 'upperRight', 'float'].forEach(pointKey => {
            const point = wave[pointKey];
            const pointReference = info.wavefrontPointsReference[pointKey];

            if (pointReference === 'incident ray') {
                this.moveAlongRay(point, wave, false);
            } else if (pointReference === 'boundary') {
                this.moveFloatToBoundary(point, wave, boundaryY);
            } else if (pointReference === 'refracted ray') {
                this.moveAlongRay(point, wave, true);
            }
        });
    }

    moveAlongRay(point, wave, isRefracted = false) {
        const gradient = isRefracted ? wave.refractedRayGradient : point.gradient;
        const velocity = isRefracted ? wave.refractedVelocity : point.velocity;

        const dx = velocity / Math.sqrt(1 + gradient ** 2);
        const dy = gradient * dx;

        point.position.x += dx;
        point.position.y += dy;
    }

    // Move the float point to the boundary, adjusting its x based on the lowerLeft position
    moveFloatToBoundary(float, wave, boundaryY) {
        float.position.y = boundaryY;
        float.position.x = this.calculateFloatPositionOnBoundary(wave.lowerLeft.position, wave, boundaryY);
    }

    updateWaves() {
        const mediumBoundaryCartesianY = this.screenToCartesian(0, info.mediumBoundaryScreenY).y;
        const refractedRayEndCartesian = this.screenToCartesian(info.refractedRay.endX, info.refractedRay.endY);

        for (let i = this.waves.length - 1; i >= 0; i--) {
            const wave = this.waves[i];
            let waveReachedEnd = false;

            this.setPointReferences(wave, mediumBoundaryCartesianY);
            this.updatePoints(wave);

            if (wave.line) {
                wave.line.clear();
            }

            // Draw two separate lines: lowerLeft to float, and float to upperRight
            wave.line = this.drawWavefront(wave.lowerLeft.position, wave.float.position, wave.upperRight.position);

            // Log if it's the first wavefront and where you would call the drawGrowingRay method
            if (i === 0) {
                this.drawGrowingRay();
            }

            if (wave.lowerLeft.position.y <= refractedRayEndCartesian.y) {
                waveReachedEnd = true;
            }

            if (waveReachedEnd) {
                wave.line.destroy();
                this.waves.splice(i, 1);
            }
        }
    }

    drawWavefront(lowerLeft, float, upperRight) {
        const waveConfig = visualizationConfig.waves;

        const { x: lowerLeftX, y: lowerLeftY } = this.cartesianToScreen(lowerLeft.x, lowerLeft.y);
        const { x: floatX, y: floatY } = this.cartesianToScreen(float.x, float.y);
        const { x: upperRightX, y: upperRightY } = this.cartesianToScreen(upperRight.x, upperRight.y);

        const waveLine = this.scene.add.graphics();
        waveLine.lineStyle(waveConfig.display.lineThickness, waveConfig.display.lineTint);

        waveLine.beginPath();
        waveLine.moveTo(lowerLeftX, lowerLeftY);
        waveLine.lineTo(floatX, floatY);
        waveLine.strokePath();

        waveLine.beginPath();
        waveLine.moveTo(floatX, floatY);
        waveLine.lineTo(upperRightX, upperRightY);
        waveLine.strokePath();

        return waveLine;
    }

    updateOnTick() {
        const waveConfig = visualizationConfig.waves;

        const gridHeight = visualizationConfig.grid.bottomRightY - visualizationConfig.grid.topLeftY;
        const squareHeight = gridHeight / visualizationConfig.grid.squaresDown;
        const pixelsPerSecond = waveConfig.gridVelocityVacuum * squareHeight;
        const ticksPerSecond = pixelsPerSecond / waveConfig.pixelVelocityIncrementPerTickVacuum;
        const ticksPerWavePeriod = ticksPerSecond * waveConfig.period;

        this.ticksSinceLastWave++;

        if (this.ticksSinceLastWave >= ticksPerWavePeriod) {
            this.spawnWave();
            this.ticksSinceLastWave = 0;
        }

        this.updateWaves();
    }

    reset() {
        // Loop through all current waves and clear their visual lines
        this.waves.forEach(wave => {
            if (wave.line) {
                wave.line.destroy(); // Remove the wave's graphical line from the scene
            }
        });

        // Clear incident and refracted ray graphics and arrows if they exist
        if (this.incidentRayGraphics) {
            this.incidentRayGraphics.clear();
            this.incidentRayGraphics.destroy(); // Remove the graphical object from the scene
            this.incidentRayGraphics = null; // Clear the reference
        }
        
        if (this.incidentArrow) {
            this.incidentArrow.destroy(); // Remove the arrow from the scene
            this.incidentArrow = null; // Clear the reference
        }
        
        if (this.refractedRayGraphics) {
            this.refractedRayGraphics.clear();
            this.refractedRayGraphics.destroy(); // Remove the graphical object from the scene
            this.refractedRayGraphics = null; // Clear the reference
        }
        
        if (this.refractedArrow) {
            this.refractedArrow.destroy(); // Remove the arrow from the scene
            this.refractedArrow = null; // Clear the reference
        }

        // Reset the variables and other values
        this.waves = [];
        this.ticksSinceLastWave = 10000000; // Workaround to force an immediate spawn but still within the flow of the code
        this.refractedRayStarted = false;
        this.endOfRayReached = false;
        this.currentIncidentX = null;
        this.currentIncidentY = null;
        this.currentRefractedX = null;
        this.currentRefractedY = null;
    }

    create() {
        this.spawnWave();
    }
}

class Angles {
    constructor(scene) {
        this.scene = scene;
        this.graphics = this.scene.add.graphics().setDepth(8); // Right angles should be on top layer
        this.drawnElements = []; // Store drawn elements
        this.labels = {}; // Initialize the labels object
    }

    reset() {
        // Clear previous drawings
        this.graphics.clear();

        // Clear the drawn elements array
        this.drawnElements = [];

        // Destroy and clear label images
        Object.keys(this.labels).forEach(labelKey => {
            if (this.labels[labelKey]) {
                this.labels[labelKey].destroy();
            }
        });
        this.labels = {}; // Reset the labels object
    }

    // Method to draw the right angle marker at point B
    drawRightAngleAtB() {
        const config = anglesConfig.rightAngle;
        const pointB = info.geometry.B;
        const pointA = info.geometry.A;
        const pointC = info.geometry.C;

        // Calculate direction vectors
        const vectorAB = { x: pointA.x - pointB.x, y: pointA.y - pointB.y };
        const vectorBC = { x: pointC.x - pointB.x, y: pointC.y - pointB.y };

        // Normalize the vectors to get unit directions
        const lengthAB = Math.sqrt(vectorAB.x ** 2 + vectorAB.y ** 2);
        const lengthBC = Math.sqrt(vectorBC.x ** 2 + vectorBC.y ** 2);

        const unitAB = { x: vectorAB.x / lengthAB, y: vectorAB.y / lengthAB };
        const unitBC = { x: vectorBC.x / lengthBC, y: vectorBC.y / lengthBC };

        // Calculate points g, h, t for the right angle marker
        const g = { x: pointB.x + unitAB.x * config.length, y: pointB.y + unitAB.y * config.length }; // A small distance along AB
        const h = { x: g.x + unitBC.x * config.length, y: g.y + unitBC.y * config.length }; // A small distance along BC
        const t = { x: pointB.x + unitBC.x * config.length, y: pointB.y + unitBC.y * config.length }; // A small distance along BC

        // Draw the right angle marker
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.brightTint);
        this.graphics.beginPath();
        this.graphics.moveTo(g.x, g.y);
        this.graphics.lineTo(h.x, h.y);
        this.graphics.lineTo(t.x, t.y);
        this.graphics.strokePath();

        // Store the drawn element
        this.drawnElements.push(this.graphics);
    }

    // Method to draw the right angle marker at point D
    drawRightAngleAtD() {
        const config = anglesConfig.rightAngle;
        const pointD = info.geometry.D;
        const pointA = info.geometry.A;
        const pointC = info.geometry.C;

        // Calculate direction vectors
        const vectorDA = { x: pointA.x - pointD.x, y: pointA.y - pointD.y };
        const vectorDC = { x: pointC.x - pointD.x, y: pointC.y - pointD.y };

        // Normalize the vectors to get unit directions
        const lengthDA = Math.sqrt(vectorDA.x ** 2 + vectorDA.y ** 2);
        const lengthDC = Math.sqrt(vectorDC.x ** 2 + vectorDC.y ** 2);

        const unitDA = { x: vectorDA.x / lengthDA, y: vectorDA.y / lengthDA };
        const unitDC = { x: vectorDC.x / lengthDC, y: vectorDC.y / lengthDC };

        // Calculate points g, h, t for the right angle marker
        const g = { x: pointD.x + unitDA.x * config.length, y: pointD.y + unitDA.y * config.length }; // A small distance along DA
        const h = { x: g.x + unitDC.x * config.length, y: g.y + unitDC.y * config.length }; // A small distance parallel to DC
        const t = { x: pointD.x + unitDC.x * config.length, y: pointD.y + unitDC.y * config.length }; // A small distance along DC

        // Draw the right angle marker
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.brightTint);
        this.graphics.beginPath();
        this.graphics.moveTo(g.x, g.y);
        this.graphics.lineTo(h.x, h.y);
        this.graphics.lineTo(t.x, t.y);
        this.graphics.strokePath();

        // Store the drawn element
        this.drawnElements.push(this.graphics);
    }

    drawGeomDullIArc() {
        const config = anglesConfig.arc;
        const pointC = info.geometry.C;

        // Set the radius for the arc
        const radius = config.radius;

        // Calculate the start and end angles in radians
        const startAngle = Phaser.Math.DegToRad(270 - values.i); // 270 - i degrees
        const endAngle = Phaser.Math.DegToRad(270); // 270 degrees (vertical line)

        // Draw the arc for the dull angle of incidence
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.dullTint);
        this.graphics.beginPath();
        this.graphics.arc(pointC.x, pointC.y, radius, startAngle, endAngle);
        this.graphics.strokePath();

        // Calculate label positioning: use fractionOfRadius for positioning label closer to the arc
        const midAngle = (startAngle + endAngle) / 2; // Midpoint of the arc for label positioning
        const labelX = pointC.x + radius * anglesConfig.label.fractionOfRadius * Math.cos(midAngle);
        const labelY = pointC.y + radius * anglesConfig.label.fractionOfRadius * Math.sin(midAngle);

        // Place the label for the angle of incidence (iDullText)
        if (!this.labels.iDullText) {
            this.labels.iDullText = this.scene.add.image(labelX, labelY, 'iDullText-img')
                .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY) // Use origin values from config
                .setDepth(15); // Ensure the label is on top
        } else {
            this.labels.iDullText.setPosition(labelX, labelY);
        }
    }

    drawGeomDullRArc() {
        const config = anglesConfig.arc;
        const pointC = info.geometry.C;

        // Set the radius for the arc
        const radius = config.radius;

        // Calculate the start and end angles in radians
        const startAngle = Phaser.Math.DegToRad(90 - values.r); // Start at 90 - r degrees (refracted ray)
        const endAngle = Phaser.Math.DegToRad(90); // End at 90 degrees (normal)

        // Draw the arc for the dull angle of refraction
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.dullTint);
        this.graphics.beginPath();
        this.graphics.arc(pointC.x, pointC.y, radius, startAngle, endAngle);
        this.graphics.strokePath();

        // Add the label for the angle of refraction (rDullText)
        const labelX = pointC.x + (radius * anglesConfig.label.fractionOfRadius) * Math.cos((startAngle + endAngle) / 2);
        const labelY = pointC.y + (radius * anglesConfig.label.fractionOfRadius) * Math.sin((startAngle + endAngle) / 2);

        if (!this.labels.rDullText) {
            this.labels.rDullText = this.scene.add.image(labelX, labelY, 'rDullText-img')
                .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY)
                .setDepth(15); // Ensure the label is on top
        } else {
            this.labels.rDullText.setPosition(labelX, labelY);
        }
    }

    drawGeomBrightIArc() {
        const config = anglesConfig.arc;
        const pointA = info.geometry.A;

        // Set the radius for the arc
        const radius = config.radius;

        // Calculate the start and end angles in radians
        const startAngle = Phaser.Math.DegToRad(360 - values.i); // 360 - i degrees
        const endAngle = Phaser.Math.DegToRad(360); // 360 degrees (horizontal line)

        // Draw the arc for the bright angle of incidence
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.brightTint);
        this.graphics.beginPath();
        this.graphics.arc(pointA.x, pointA.y, radius, startAngle, endAngle);
        this.graphics.strokePath();

        // Add the label for the angle of incidence (iBrightText)
        const labelX = pointA.x + (radius * anglesConfig.label.fractionOfRadius) * Math.cos((startAngle + endAngle) / 2);
        const labelY = pointA.y + (radius * anglesConfig.label.fractionOfRadius) * Math.sin((startAngle + endAngle) / 2);

        if (!this.labels.iBrightText) {
            this.labels.iBrightText = this.scene.add.image(labelX, labelY, 'iBrightText-img')
                .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY)
                .setDepth(15); // Ensure the label is on top
        } else {
            this.labels.iBrightText.setPosition(labelX, labelY);
        }
    }

    drawGeomBrightRArc() {
        const config = anglesConfig.arc;
        const pointC = info.geometry.C;

        // Set the radius for the arc
        const radius = config.radius;

        // Calculate the start and end angles in radians
        const startAngle = Phaser.Math.DegToRad(180 - values.r); // 180 - r degrees
        const endAngle = Phaser.Math.DegToRad(180); // 180 degrees (horizontal line)

        // Draw the arc for the bright angle of refraction
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.brightTint);
        this.graphics.beginPath();
        this.graphics.arc(pointC.x, pointC.y, radius, startAngle, endAngle);
        this.graphics.strokePath();

        // Add the label for the angle of refraction (rBrightText)
        const labelX = pointC.x + (radius * anglesConfig.label.fractionOfRadius) * Math.cos((startAngle + endAngle) / 2);
        const labelY = pointC.y + (radius * anglesConfig.label.fractionOfRadius) * Math.sin((startAngle + endAngle) / 2);

        if (!this.labels.rBrightText) {
            this.labels.rBrightText = this.scene.add.image(labelX, labelY, 'rBrightText-img')
                .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY)
                .setDepth(15); // Ensure the label is on top
        } else {
            this.labels.rBrightText.setPosition(labelX, labelY);
        }
    }

    drawIncidentArc() {

        const config = anglesConfig.arc;
        const { endX, endY } = info.incidentRay; // Use incident ray end point as center for the arc

        // Set the radius for the arc
        const radius = config.radius;

        // Calculate the start and end angles in radians for the incident ray
        const startAngle = Phaser.Math.DegToRad(270 - values.i); // Start at 270 - i degrees
        const endAngle = Phaser.Math.DegToRad(270); // End at 270 degrees (vertical)

        // Draw the arc for the incident angle
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.brightTint);
        this.graphics.beginPath();
        this.graphics.arc(endX, endY, radius, startAngle, endAngle);
        this.graphics.strokePath();

        // Calculate label positioning: use fractionOfRadius for positioning the label
        const midAngle = (startAngle + endAngle) / 2; // Midpoint of the arc for label
        const labelX = endX + radius * anglesConfig.label.fractionOfRadius * Math.cos(midAngle);
        const labelY = endY + radius * anglesConfig.label.fractionOfRadius * Math.sin(midAngle);

        // Place the label for the incident angle (iBrightText)
        if (!this.labels.iBrightText) {
            this.labels.iBrightText = this.scene.add.image(labelX, labelY, 'iBrightText-img')
                .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY)
                .setDepth(15);
        } else {
            this.labels.iBrightText.setPosition(labelX, labelY);
        }
    }

    drawRefractedArc() {
        const config = anglesConfig.arc;
        const { startX, startY } = info.refractedRay; // Use refracted ray start point as center for the arc

        // Set the radius for the arc
        const radius = config.radius;

        // Calculate the start and end angles in radians for the refracted ray
        const startAngle = Phaser.Math.DegToRad(90 - values.r); // Start at 90 - r degrees
        const endAngle = Phaser.Math.DegToRad(90); // End at 90 degrees (horizontal)

        // Draw the arc for the refracted angle
        this.graphics.lineStyle(anglesConfig.line.thickness, anglesConfig.line.brightTint);
        this.graphics.beginPath();
        this.graphics.arc(startX, startY, radius, startAngle, endAngle);
        this.graphics.strokePath();

        // Add the label for the refracted angle (rBrightText)
        const midAngle = (startAngle + endAngle) / 2;
        const labelX = startX + radius * anglesConfig.label.fractionOfRadius * Math.cos(midAngle);
        const labelY = startY + radius * anglesConfig.label.fractionOfRadius * Math.sin(midAngle);

        if (!this.labels.rBrightText) {
            this.labels.rBrightText = this.scene.add.image(labelX, labelY, 'rBrightText-img')
                .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY)
                .setDepth(15);
        } else {
            this.labels.rBrightText.setPosition(labelX, labelY);
        }
    }

    toggleDisplayValuesOrVariable(){
        this.updateIncidentAngleLabel();
        this.updateRefractedAngleLabel();
    }

    // Method to replace the incident angle label with the actual angle value if showValues.i is true
    updateIncidentAngleLabel() {
        const config = anglesConfig.arc;
        const { endX, endY } = info.incidentRay; // Use incident ray end point as center for the arc
        const radius = config.radius;
        const midAngle = Phaser.Math.DegToRad(270 - values.i / 2); // Calculate the midpoint angle

        // Calculate the position for the label or text
        const labelX = endX + radius * anglesConfig.label.fractionOfRadius * Math.cos(midAngle);
        const labelY = endY + radius * anglesConfig.label.fractionOfRadius * Math.sin(midAngle);

        if (showValues.i) {
            // If showValues.i is true, display the angle value in degrees
            const angleText = `${Math.round(values.i)}\u00B0`;

            // Check if the text already exists, otherwise create it
            if (!this.labels.iAngleText) {
                this.labels.iAngleText = this.scene.add.text(labelX, labelY, angleText, {
                    font: `${anglesConfig.valueDisplay.textSize}px ${anglesConfig.valueDisplay.font}`,
                    fill: anglesConfig.valueDisplay.tint
                }).setOrigin(anglesConfig.label.originX, anglesConfig.label.originY).setDepth(15);
            } else {
                this.labels.iAngleText.setText(angleText).setPosition(labelX, labelY);
            }

            // Destroy the image label if it exists
            if (this.labels.iBrightText) {
                this.labels.iBrightText.destroy();
                this.labels.iBrightText = null;
            }

        } else {
            // If showValues.i is false, display the generic image label
            if (!this.labels.iBrightText) {
                this.labels.iBrightText = this.scene.add.image(labelX, labelY, 'iBrightText-img')
                    .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY).setDepth(15);
            } else {
                this.labels.iBrightText.setPosition(labelX, labelY);
            }

            // Destroy the angle text if it exists
            if (this.labels.iAngleText) {
                this.labels.iAngleText.destroy();
                this.labels.iAngleText = null;
            }
        }
    }

    // Method to replace the refracted angle label with the actual angle value if showValues.r is true
    updateRefractedAngleLabel() {
        const config = anglesConfig.arc;
        const { startX, startY } = info.refractedRay; // Use refracted ray start point as center for the arc
        const radius = config.radius;
        const midAngle = Phaser.Math.DegToRad(90 - values.r / 2); // Calculate the midpoint angle

        // Calculate the position for the label or text
        const labelX = startX + radius * anglesConfig.label.fractionOfRadius * Math.cos(midAngle);
        const labelY = startY + radius * anglesConfig.label.fractionOfRadius * Math.sin(midAngle);

        if (showValues.r) {
            // If showValues.r is true, display the angle value in degrees
            const angleText = `${Math.round(values.r)}\u00B0`;

            // Check if the text already exists, otherwise create it
            if (!this.labels.rAngleText) {
                this.labels.rAngleText = this.scene.add.text(labelX, labelY, angleText, {
                    font: `${anglesConfig.valueDisplay.textSize}px ${anglesConfig.valueDisplay.font}`,
                    fill: anglesConfig.valueDisplay.tint
                }).setOrigin(anglesConfig.label.originX, anglesConfig.label.originY).setDepth(15);
            } else {
                this.labels.rAngleText.setText(angleText).setPosition(labelX, labelY);
            }

            // Destroy the image label if it exists
            if (this.labels.rBrightText) {
                this.labels.rBrightText.destroy();
                this.labels.rBrightText = null;
            }

        } else {
            // If showValues.r is false, display the generic image label
            if (!this.labels.rBrightText) {
                this.labels.rBrightText = this.scene.add.image(labelX, labelY, 'rBrightText-img')
                    .setOrigin(anglesConfig.label.originX, anglesConfig.label.originY).setDepth(15);
            } else {
                this.labels.rBrightText.setPosition(labelX, labelY);
            }

            // Destroy the angle text if it exists
            if (this.labels.rAngleText) {
                this.labels.rAngleText.destroy();
                this.labels.rAngleText = null;
            }
        }
    }
}

class Geometry {

    // The quadrilateral is implicitly labelled ABCD starting at the bottom left end of incident wavefront and going clockwise
    constructor(scene) {
        this.scene = scene;
        this.graphics = this.scene.add.graphics().setDepth(10); // Used to draw the shapes
        this.labels = {}; // Store label images for easy access
    }

    create() {
        this.updateRefractionAngle(); // Update r using Snell's law
        this.drawLineAB();
        this.drawLineAC();
        this.drawNormalAtC();
        this.drawLineBC();
        this.drawLineCD();
        this.drawLineDA();
        this.drawLeftMainRayUp();
        this.drawRightMainRayUp();
        this.drawLeftMainRayDown();
        this.drawRightMainRayDown();

        angles.drawRightAngleAtB();
        angles.drawRightAngleAtD();

        angles.drawGeomDullIArc();
        angles.drawGeomDullRArc();
        angles.drawGeomBrightIArc();
        angles.drawGeomBrightRArc();
    }

    reset() {
        this.graphics.clear();
        angles.reset();

        // Destroy and clear label images
        Object.keys(this.labels).forEach(labelKey => {
            if (this.labels[labelKey]) {
                this.labels[labelKey].destroy();
            }
        });
        this.labels = {}; // Reset the labels object
    }

    drawLineAB() {
        const config = geometryConfig.incomingWavefront;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;

        const startX = visualizationConfig.grid.topLeftX + geometryConfig.originX * squareWidth;
        const startY = info.mediumBoundaryScreenY;

        const lengthInPixels = config.orientation.length * squareWidth;
        const angleInRadians = Phaser.Math.DegToRad(values.i);
        const endX = startX + lengthInPixels * Math.cos(angleInRadians);
        const endY = startY - lengthInPixels * Math.sin(angleInRadians);

        info.geometry.A.x = startX;
        info.geometry.A.y = startY;
        info.geometry.B.x = endX;
        info.geometry.B.y = endY;

        this.graphics.lineStyle(config.line.thickness, config.line.tint);
        this.graphics.beginPath();
        this.graphics.moveTo(startX, startY);
        this.graphics.lineTo(endX, endY);
        this.graphics.strokePath();
    }

    drawLineAC() {
        const config = geometryConfig.commonHypoteneus;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;

        const startX = info.geometry.A.x;
        const startY = info.geometry.A.y;

        // Calculate the length of AC using trigonometry (from config)
        const lengthAB = Phaser.Math.Distance.Between(info.geometry.A.x, info.geometry.A.y, info.geometry.B.x, info.geometry.B.y);
        const lengthAC = lengthAB / Math.cos(Phaser.Math.DegToRad(values.i));

        const endX = startX + lengthAC;
        const endY = startY; // Same Y-coordinate since it's a horizontal line

        info.geometry.C.x = endX;
        info.geometry.C.y = endY;

        this.drawDottedLine(startX, startY, endX, endY, config.line.thickness, config.line.tint);

        // Create the label for line AC (h)
        const labelX = (startX + endX) / 2;
        const labelY = startY - geometryConfig.labelSpacing; // Label above the line

        if (!this.labels.h) {
            this.labels.h = this.scene.add.image(labelX, labelY, config.labelImage.name)
                .setOrigin(config.labelImage.originX, config.labelImage.originY);
        } else {
            this.labels.h.setPosition(labelX, labelY);
        }
    }

    drawLineBC() {
        const config = geometryConfig.rightMainRay;

        const startX = info.geometry.B.x;
        const startY = info.geometry.B.y;
        const endX = info.geometry.C.x;
        const endY = info.geometry.C.y;

        this.graphics.lineStyle(config.line.thickness, config.line.tint);
        this.graphics.beginPath();
        this.graphics.moveTo(startX, startY);
        this.graphics.lineTo(endX, endY);
        this.graphics.strokePath();

        // Add the label for line BC, positioned a quarter from the top
        const labelX = (startX + endX) / 2 + geometryConfig.labelSpacing; // Label to the right of the line
        const labelY = (3 * startY + endY) / 4; // A quarter of the way from the top

        if (!this.labels.tEqualsHsiniOverC) {
            this.labels.tEqualsHsiniOverC = this.scene.add.image(labelX, labelY, config.labelImage.name)
                .setOrigin(config.labelImage.originX, config.labelImage.originY).setDepth(15);
        } else {
            this.labels.tEqualsHsiniOverC.setPosition(labelX, labelY);
        }
    }

    drawLineCD() {
        const config = geometryConfig.outgoingWavefront;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;

        const startX = info.geometry.C.x;
        const startY = info.geometry.C.y;

        // Calculate the length of CD using trigonometry
        const lengthAC = Phaser.Math.Distance.Between(info.geometry.A.x, info.geometry.A.y, info.geometry.C.x, info.geometry.C.y);
        const lengthCD = lengthAC * Math.cos(Phaser.Math.DegToRad(values.r)); // Same proportion as AB to AC for r

        // Calculate the end point (D) based on angle r
        const angleInRadians = Phaser.Math.DegToRad(values.r);
        const endX = startX - lengthCD * Math.cos(angleInRadians); // Moving to the left
        const endY = startY + lengthCD * Math.sin(angleInRadians); // Moving downward

        info.geometry.D.x = endX;
        info.geometry.D.y = endY;

        // Draw the line CD
        this.graphics.lineStyle(config.line.thickness, config.line.tint);
        this.graphics.beginPath();
        this.graphics.moveTo(startX, startY);
        this.graphics.lineTo(endX, endY);
        this.graphics.strokePath();
    }

    drawLineDA() {
        const config = geometryConfig.leftMainRay;

        const startX = info.geometry.D.x;
        const startY = info.geometry.D.y;
        const endX = info.geometry.A.x;
        const endY = info.geometry.A.y;

        // Draw the line DA
        this.graphics.lineStyle(config.line.thickness, config.line.tint);
        this.graphics.beginPath();
        this.graphics.moveTo(startX, startY);
        this.graphics.lineTo(endX, endY);
        this.graphics.strokePath();

        // Add the label for line DA
        const labelX = (startX + endX) / 2 - geometryConfig.labelSpacing; // Label to the left of the line
        const labelY = (startY + endY) / 2; // Midpoint of the line

        if (!this.labels.tEqualsHsiniOverCOverN) {
            this.labels.tEqualsHsiniOverCOverN = this.scene.add.image(labelX, labelY, config.labelImage.name)
                .setOrigin(config.labelImage.originX, config.labelImage.originY);
        } else {
            this.labels.tEqualsHsiniOverCOverN.setPosition(labelX, labelY);
        }
    }

    drawLeftMainRayUp() {
        const config = geometryConfig.leftMainRayUp;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;

        const startX = info.geometry.A.x;
        const startY = info.geometry.A.y;

        // Calculate the end point of the ray (AUp) using trigonometry
        const angleInRadians = Phaser.Math.DegToRad(values.i); // Convert i to radians
        const lengthInPixels = config.orientation.length * squareWidth;

        const endX = startX - lengthInPixels * Math.sin(angleInRadians); // Moving left
        const endY = startY - lengthInPixels * Math.cos(angleInRadians); // Moving up

        // Draw the dotted line for the ray
        this.drawDottedLine(startX, startY, endX, endY, config.line.thickness, config.line.tint);

        // Calculate the rotation angle for the arrow: 180 - i (clockwise)
        const arrowRotation = Phaser.Math.DegToRad(180 - values.i);

        // Create or update the arrow image at the midpoint of the ray
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;

        //'arrowPink-img'
        if (!this.labels.leftMainRayUpArrow) {
            this.labels.leftMainRayUpArrow = this.scene.add.image(midX, midY, config.line.arrow)
                .setOrigin(0.5, 0.5)
                .setRotation(arrowRotation);
        } else {
            this.labels.leftMainRayUpArrow.setPosition(midX, midY);
            this.labels.leftMainRayUpArrow.setRotation(arrowRotation);
        }
    }

    drawRightMainRayUp() {
        const config = geometryConfig.rightMainRayUp;

        const startX = info.geometry.B.x;
        const startY = info.geometry.B.y;

        // Get grid dimensions to convert squares to pixels
        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const gridHeight = visualizationConfig.grid.bottomRightY - visualizationConfig.grid.topLeftY;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;
        const squareHeight = gridHeight / visualizationConfig.grid.squaresDown;

        // Calculate the length of the ray in pixels (based on squares)
        const lengthInPixels = config.orientation.length * squareHeight; // Use height since it's vertical

        // Calculate the end point (upward and to the left)
        const angleInRadians = Phaser.Math.DegToRad(values.i);
        const endX = startX - lengthInPixels * Math.sin(angleInRadians); // Moving to the left
        const endY = startY - lengthInPixels * Math.cos(angleInRadians); // Moving upward

        // Draw the dotted line
        this.drawDottedLine(startX, startY, endX, endY, config.line.thickness, config.line.tint);

        // Add the arrow at the midpoint, rotated (180 - i) degrees
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;

        const arrowAngle = 180 - values.i; // Rotate arrow clockwise (180 - i) degrees
        if (!this.labels.rightMainRayUpArrow) {
            this.labels.rightMainRayUpArrow = this.scene.add.image(midX, midY, config.line.arrow)
                .setOrigin(0.5, 0.5)
                .setRotation(Phaser.Math.DegToRad(arrowAngle));
        } else {
            this.labels.rightMainRayUpArrow.setPosition(midX, midY);
            this.labels.rightMainRayUpArrow.setRotation(Phaser.Math.DegToRad(arrowAngle));
        }
    }

    drawLeftMainRayDown() {
        const config = geometryConfig.leftMainRayDown;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;

        const startX = info.geometry.D.x;
        const startY = info.geometry.D.y;

        // Calculate the length of the line
        const lengthInPixels = config.orientation.length * squareWidth;
        const angleInRadians = Phaser.Math.DegToRad(values.r);

        // Calculate the end point of the line
        const endX = startX + lengthInPixels * Math.sin(angleInRadians); // moving right
        const endY = startY + lengthInPixels * Math.cos(angleInRadians); // moving downward

        info.geometry.DDown = { x: endX, y: endY };

        // Draw the dotted line using the helper method
        this.drawDottedLine(startX, startY, endX, endY, config.line.thickness, config.line.tint);

        // Add the arrow
        const arrowX = (startX + endX) / 2;
        const arrowY = (startY + endY) / 2;
        const arrowAngle = 180 - values.r; // Rotate the arrow based on the angle of refraction

        if (!this.labels.leftMainRayDownArrow) {
            this.labels.leftMainRayDownArrow = this.scene.add.image(arrowX, arrowY, config.line.arrow)
                .setOrigin(0.5)
                .setRotation(Phaser.Math.DegToRad(arrowAngle));
        } else {
            this.labels.leftMainRayDownArrow.setPosition(arrowX, arrowY).setRotation(Phaser.Math.DegToRad(arrowAngle));
        }
    }

    drawRightMainRayDown() {
        const config = geometryConfig.rightMainRayDown;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const squareWidth = gridWidth / visualizationConfig.grid.squaresAcross;

        const startX = info.geometry.C.x;
        const startY = info.geometry.C.y;

        // Calculate the length of the line
        const lengthInPixels = config.orientation.length * squareWidth;
        const angleInRadians = Phaser.Math.DegToRad(values.r);

        // Calculate the end point of the line
        const endX = startX + lengthInPixels * Math.sin(angleInRadians); // moving right
        const endY = startY + lengthInPixels * Math.cos(angleInRadians); // moving downward

        info.geometry.CDown = { x: endX, y: endY };

        // Draw the dotted line using the helper method
        this.drawDottedLine(startX, startY, endX, endY, config.line.thickness, config.line.tint);

        // Add the arrow
        const arrowX = (startX + endX) / 2;
        const arrowY = (startY + endY) / 2;
        const arrowAngle = 180 - values.r; // Rotate the arrow based on the angle of refraction

        if (!this.labels.rightMainRayDownArrow) {
            this.labels.rightMainRayDownArrow = this.scene.add.image(arrowX, arrowY, config.line.arrow)
                .setOrigin(0.5)
                .setRotation(Phaser.Math.DegToRad(arrowAngle));
        } else {
            this.labels.rightMainRayDownArrow.setPosition(arrowX, arrowY).setRotation(Phaser.Math.DegToRad(arrowAngle));
        }
    }

    drawNormalAtC() {
        const config = geometryConfig.normal;

        const gridWidth = visualizationConfig.grid.bottomRightX - visualizationConfig.grid.topLeftX;
        const gridHeight = visualizationConfig.grid.bottomRightY - visualizationConfig.grid.topLeftY;
        const squareHeight = gridHeight / visualizationConfig.grid.squaresDown;

        // Set the X-coordinate to be at point C
        const startX = info.geometry.C.x;

        // Calculate the starting Y-coordinate, one square down from the top of the grid
        const startY = visualizationConfig.grid.topLeftY + config.orientation.startSquaresDown * squareHeight;

        // Calculate the end Y-coordinate based on the length of the normal (in squares)
        const lengthInPixels = config.orientation.length * squareHeight;
        const endY = startY + lengthInPixels; // Extending down from the start point

        // Draw the dotted line for the normal
        this.drawDottedLine(startX, startY, startX, endY, config.line.thickness, config.line.tint);
    }

    // Helper method to draw a dotted line
    drawDottedLine(startX, startY, endX, endY, lineThickness, lineTint) {
        const dotLength = geometryConfig.dots.line;
        const gapLength = geometryConfig.dots.gap;

        this.graphics.lineStyle(lineThickness, lineTint);

        const totalDistance = Phaser.Math.Distance.Between(startX, startY, endX, endY);
        const directionX = (endX - startX) / totalDistance;
        const directionY = (endY - startY) / totalDistance;

        let drawnDistance = 0;
        this.graphics.beginPath();

        while (drawnDistance < totalDistance) {
            const currentX = startX + directionX * drawnDistance;
            const currentY = startY + directionY * drawnDistance;
            const nextSegmentLength = Math.min(dotLength, totalDistance - drawnDistance);
            const nextX = currentX + directionX * nextSegmentLength;
            const nextY = currentY + directionY * nextSegmentLength;

            this.graphics.moveTo(currentX, currentY);
            this.graphics.lineTo(nextX, nextY);

            drawnDistance += nextSegmentLength + gapLength;
        }

        this.graphics.strokePath();
    }

    // Method to update the refraction angle r using Snell's law
    updateRefractionAngle() {
        const n1 = 1; // Refractive index of the first medium (air)
        const n2 = values.n; // Refractive index of the second medium from the slider
        const i = Phaser.Math.DegToRad(values.i); // Convert incidence angle i to radians

        const sinR = (n1 / n2) * Math.sin(i);

        // Ensure valid arcsin value and calculate r (in degrees)
        if (sinR <= 1) {
            values.r = Phaser.Math.RadToDeg(Math.asin(sinR)); // Store r in values object
        } else {
            values.r = 90; // Handle total internal reflection case if needed
        }
    }
}

class Visualization {
    constructor(scene) {
        this.scene = scene;
        this.currentVisualization = 'ray'; //values 'ray', 'wavefront', 'geometry'

        this.mediumRect = null; // Store the rectangle for the medium
        this.waves = []; // Store the wavefront images
        this.ticksSinceLastWave = 0; // Time tracker for wave spawning
    }

    create() {
        // Draw the medium to the right of the grid
        this.createMedium();
        this.createNormal();
        this.createRays();
        this.createWavefronts();
        this.createGeometry();
    }

    changeVisualization() {
        this.hideEverything();
        
        const v = this.currentVisualization;

        switch (v) {
            case 'ray':
                rayBackground.setVisible(true);
                this.createNormal();
                this.createRays();
                this.toggleShowAngleValue();
                ui.toggleSwitchVisibility(true); // Show switches for ray visualization
                ui.togglePlayPauseVisibility(false); // Show play/pause button
            break;

            case 'wavefront':
                wavefrontBackground.setVisible(true);
                this.createWavefronts();
                ui.toggleSwitchVisibility(false); // Hide switches for wavefront visualization
                ui.togglePlayPauseVisibility(true); // Hide play/pause button
            break;

            case 'geometry':
                geometryBackground.setVisible(true);
                this.createGeometry();
                ui.toggleSwitchVisibility(false); // Hide switches for geometry visualization
                ui.togglePlayPauseVisibility(false); // Hide play/pause button
            break;
        }
    }

    toggleShowAngleValue() {
        if (this.currentVisualization == 'ray') {
            angles.toggleDisplayValuesOrVariable();            
        }
    }

    hideEverything() {
        rayBackground.setVisible(false);
        rays.clearRays();

        wavefrontBackground.setVisible(false);
        wavefronts.reset();

        geometryBackground.setVisible(false);
        geometry.reset();

        angles.reset();

        this.removeNormal();
    }

    createRays() {
        rays.drawIncidentAndRefractedRays();
    }

    createGeometry() {
        geometry.reset();
        geometry.create();
    }

    createWavefronts() {
        wavefronts.create();
    }

    createMedium() {
        const config = visualizationConfig;
        const gridHeight = config.grid.bottomRightY - config.grid.topLeftY;
        const mediumStartY = config.grid.topLeftY + (config.medium.mediumBoundary * gridHeight);

        info.mediumBoundaryScreenY = mediumStartY;

        // Create a rectangle for the medium at the bottom of the grid
        this.mediumRect = this.scene.add.rectangle(
            config.grid.topLeftX,                       // Start at the left side of the grid
            mediumStartY,                               // Start at the medium boundary vertically
            config.grid.bottomRightX - config.grid.topLeftX, // Full grid width
            gridHeight * (1 - config.medium.mediumBoundary), // Fraction of the grid height for the medium
            config.medium.mediumTint                    // Use the mediumTint directly (0x... format)
        ).setOrigin(0, 0).setAlpha(this.calculateAlphaFromN()); // Set initial alpha
    }

    createNormal() {
        const config = visualizationConfig;
        const gridWidth = config.grid.bottomRightX - config.grid.topLeftX;
        const gridHeight = config.grid.bottomRightY - config.grid.topLeftY;
        const squareWidth = gridWidth / config.grid.squaresAcross;
        const squareHeight = gridHeight / config.grid.squaresDown;

        const normalX = config.grid.topLeftX + (config.normal.squaresAcross * squareWidth); // X-position based on squaresAcross
        const normalY = config.grid.topLeftY + (config.normal.startSquaresDown * squareHeight); // Y-position starts 1 square down
        const normalHeight = config.normal.lengthInSquares * squareHeight; // Length of the normal in pixels

        // Create the normal image and scale it to fit the height of 6 squares
        this.normal = this.scene.add.image(normalX, normalY, 'normal-img');
        this.normal.setOrigin(0.5, 0); // Set origin to top center for correct vertical alignment
        this.normal.setDisplaySize(this.normal.width, normalHeight); // Adjust height to span 6 squares
    }

    removeNormal() {
        if (this.normal) {
            this.normal.destroy(); // Remove the normal image from the scene
            this.normal = null; // Clear the reference to the normal image
        }
    }

    calculateAlphaFromN() {
        const minAlpha = visualizationConfig.medium.minAlpha;
        const maxAlpha = visualizationConfig.medium.maxAlpha;
        const normalizedValue = Phaser.Math.Clamp((values.n - sliderConfig.sliders.refractiveIndexHandle.minVal) /
            (sliderConfig.sliders.refractiveIndexHandle.maxVal - sliderConfig.sliders.refractiveIndexHandle.minVal), 0, 1);

        return minAlpha + (normalizedValue * (maxAlpha - minAlpha));
    }

    updateOnSliderDrag(sliderType) {
        if (sliderType === 'n') {
            // Set the alpha value for the medium rectangle based on slider input
            this.mediumRect.setAlpha(this.calculateAlphaFromN());
        }

        const v = this.currentVisualization;

        switch (v) {
            case 'ray':
                this.createRays();
                this.toggleShowAngleValue(); // will update the angle value if showing
            break;

            case 'wavefront':
                wavefronts.reset();
            break;

            case 'geometry':
                this.createGeometry();
            break;
        }
    }

    updateOnTick() {

        const v = this.currentVisualization;

        switch (v) {
            case 'ray':
                //no update actions
            break;

            case 'wavefront':
                wavefronts.updateOnTick();
            break;

            case 'geometry':
                //no update actions
            break;
        }
    }

    reset() {      
        // Reset the medium to the correct opacity based on the current refractive index
        this.mediumRect.setAlpha(this.calculateAlphaFromN());
    }
}

class RadioButtonGroup {
    constructor(scene, config, groupKey) {
        this.scene = scene;
        this.config = config;
        this.group = config[groupKey];
        this.buttons = {}; // Store button images for easy access during selection
    }

    create() {
        let yPos = this.group.startY;

        // Explicitly loop only through the buttons in the group
        const buttonKeys = Object.keys(this.group).filter(key => key.startsWith('button'));

        buttonKeys.forEach(buttonKey => {
            const buttonConfig = this.group[buttonKey];
            const isSelected = (buttonKey === this.group.selected);

            // Create the button image
            const buttonImage = this.scene.add.image(
                this.config.x,
                yPos,
                isSelected ? 'radioButtonSelected-img' : 'radioButtonUnselected-img'
            )
            .setScale(this.config.scale)
            .setOrigin(this.config.originX, this.config.originY)
            .setInteractive({ cursor: 'pointer' });

            // Store the button image in the buttons object
            this.buttons[buttonKey] = buttonImage;

            // Add click event listener
            buttonImage.on('pointerdown', () => {
                this.selectButton(buttonKey);
            });

            yPos += this.config.verticalSpacing;
        });
    }

    selectButton(buttonKey) {

        // Update the selected button
        this.group.selected = buttonKey;

        // Set all buttons to unselected state
        for (const key in this.buttons) {
            this.buttons[key].setTexture('radioButtonUnselected-img');
        }

        // Set the selected button to selected state
        this.buttons[buttonKey].setTexture('radioButtonSelected-img');

        visualization.currentVisualization = this.group[buttonKey].ref;
        visualization.changeVisualization();
    }
}

class Rays {
    constructor(scene) {
        this.scene = scene;
        this.rays = []; // Array to store ray objects (lines)
        this.arrows = []; // Array to store arrow images
    }

    // Method to draw the incident and refracted rays
    drawIncidentAndRefractedRays() {
        this.clearRays(); // Clear existing rays first

        // Calculate the coordinates of the incident ray
        let { startX, startY, endX, endY } = this.calculateIncidentRay();

        // Update the info object for the incident ray
        info.incidentRay.startX = startX;
        info.incidentRay.startY = startY;
        info.incidentRay.endX = endX;
        info.incidentRay.endY = endY;

        // The Ray class calculates useful values for the info object used by Wavefronts so only display the ray if that's the current visualization
        if (visualization.currentVisualization === 'ray') {
            this.drawRay(startX, startY, endX, endY);        
        }

        // Calculate and draw the refracted ray
        this.drawRefractedRay(endX, endY); // Start at the end of the incident ray

        angles.drawIncidentArc();
        angles.drawRefractedArc();
    }

    // Method to draw a ray from start to end points, with an arrow in the middle
    drawRay(startX, startY, endX, endY) {
        const config = raysConfig;

        // Create a new graphics object for the ray
        const ray = this.scene.add.graphics();
        ray.lineStyle(config.lineThickness, config.lineTint);
        ray.beginPath();
        ray.moveTo(startX, startY);
        ray.lineTo(endX, endY);
        ray.strokePath();

        // Store the ray object in the rays array
        this.rays.push(ray);

        // Calculate the midpoint of the ray
        const midX = (startX + endX) / 2;
        const midY = (startY + endY) / 2;

        // Create the arrow image at the midpoint
        const arrow = this.scene.add.image(midX, midY, config.arrow.image);
        arrow.setOrigin(config.arrow.originX, config.arrow.originY);

        // Rotate the arrow to align with the ray's direction + 90 degrees (/2 radians)
        const angle = Phaser.Math.Angle.Between(startX, startY, endX, endY) + Phaser.Math.PI2 / 4;
        arrow.setRotation(angle);

        // Store the arrow object in the arrows array
        this.arrows.push(arrow);
    }

    // Method to clear all existing rays and arrows
    clearRays() {
        // Clear all ray graphics
        this.rays.forEach(ray => ray.clear());
        this.rays = []; // Reset the array

        // Destroy all arrow images
        this.arrows.forEach(arrow => arrow.destroy());
        this.arrows = []; // Reset the array

        angles.reset();
    }

    // Method to calculate the start and end coordinates of the incident ray
    calculateIncidentRay() {
        const config = visualizationConfig;
        const gridWidth = config.grid.bottomRightX - config.grid.topLeftX;
        const gridHeight = config.grid.bottomRightY - config.grid.topLeftY;
        const squareWidth = gridWidth / config.grid.squaresAcross;
        const squareHeight = gridHeight / config.grid.squaresDown;
        const rayLength = raysConfig.lengthInSquares * squareHeight; // Fixed length of the ray

        // Get the angle of incidence (in degrees) from the global values
        // Convert to radians, and adjust to be relative to the horizontal (90 degrees - angle of incidence)
        const angleOfIncidence = Phaser.Math.DegToRad(90 - values.i); // Convert to radians, relative to the normal

        // End point (intersection with normal)
        const normalX = config.grid.topLeftX + (config.normal.squaresAcross * squareWidth); // X-position based on squaresAcross
        const normalY = config.grid.topLeftY + (config.medium.mediumBoundary * gridHeight); // Y-position at the top of the medium

        // Calculate the start point of the ray using the fixed length and angle
        const startX = normalX - rayLength * Math.cos(angleOfIncidence);
        const startY = normalY - rayLength * Math.sin(angleOfIncidence);

        return { startX, startY, endX: normalX, endY: normalY };
    }

    // Method to calculate the angle of refraction and coordinates for the refracted ray
    calculateRefractedRay(endX, endY) {
        const n1 = 1; // Assume air has a refractive index of 1
        const n2 = values.n; // Refractive index of the second medium (from slider)
        const angleOfIncidence = Phaser.Math.DegToRad(values.i); // Convert angle to radians

        // Snell's Law: n1 * sin(1) = n2 * sin(2)
        const sinTheta2 = (n1 / n2) * Math.sin(angleOfIncidence);

        // Ensure the value is within the valid range for arcsin
        let angleOfRefraction;
        if (sinTheta2 > 1) {
            // Total internal reflection case, angle of refraction undefined
            angleOfRefraction = Phaser.Math.PI2 / 2; // 90 degrees, just in case
        } else {
            angleOfRefraction = Math.asin(sinTheta2); // Angle in radians
        }

        // Convert the angle of refraction back to degrees and store it in values
        values.r = Phaser.Math.RadToDeg(angleOfRefraction);

        // Adjust the angle to be measured from the normal (90 degrees)
        const adjustedAngle = Phaser.Math.PI2 / 4 - angleOfRefraction; // 90 degrees - refraction angle

        // Calculate the refracted ray length and its end point
        const rayLength = raysConfig.lengthInSquares * (visualizationConfig.grid.bottomRightY - visualizationConfig.grid.topLeftY) / visualizationConfig.grid.squaresDown;
        const refractedEndX = endX + rayLength * Math.cos(adjustedAngle); // X calculated using the adjusted angle
        const refractedEndY = endY + rayLength * Math.sin(adjustedAngle); // Y calculated using the adjusted angle

        // Update the info object for the refracted ray
        info.refractedRay.startX = endX;
        info.refractedRay.startY = endY;
        info.refractedRay.endX = refractedEndX;
        info.refractedRay.endY = refractedEndY;

        return { startX: endX, startY: endY, endX: refractedEndX, endY: refractedEndY };
    }

    // Method to draw the refracted ray
    drawRefractedRay(startX, startY) {
        // Calculate the refracted ray coordinates
        const { endX, endY } = this.calculateRefractedRay(startX, startY);

        // Draw the refracted ray

        if (visualization.currentVisualization === 'ray') {
            this.drawRay(startX, startY, endX, endY);            
        }
    }
}

class CustomImage {
    constructor(scene, imageName, configRef){
        this.scene = scene;
        this.imageName = imageName;
        this.configRef = configRef;
    }

    create(){
        this.image = this.scene.add.image(this.configRef.x, this.configRef.y, this.imageName);
        this.image.setScale(this.configRef.scale);
        this.image.setOrigin(this.configRef.originX, this.configRef.originY);
    }

    setPosition(x, y) {
        this.image.setPosition(x, y);
    }

    setVisible(visible) {
        this.image.setVisible(visible);
    }
}

class Slider {
    constructor(scene, name) {
        this.scene = scene;
        this.name = name;
        this.config = sliderConfig.sliders[name];
        this.handleConfig = sliderConfig.handle;
        this.handle = null;
        this.track = null;
    }

    create() {
        this.createTrack(); // Create track before creating handle
        this.handle = this.scene.add.image(this.calculateInitialPosition(), this.config.y, 'handle');
        this.handle.setOrigin(this.handleConfig.originX, this.handleConfig.originY);
        this.handle.setScale(this.handleConfig.scale);
        this.handle.setInteractive({ useHandCursor: true });
        this.addDragBehavior();
        this.updateTrack(); // Initial track update
    }

    createTrack() {
        const { slideLeftX, slideRightX, y } = this.handleConfig;
        this.track = this.scene.add.graphics();
        this.track.lineStyle(sliderConfig.track.lineThickness, sliderConfig.track.lineTint);
        this.updateTrack(); // Ensure track is initially updated
    }

    destroyTrack() {
        if (this.track) {
            this.track.destroy();
            this.track = null;
        }
    }

    updateTrack() {
        if (this.handle && this.track) {
            const { slideLeftX, slideRightX } = this.handleConfig;
            const handleX = this.handle.x;
            const { y } = this.config;
            const zeroX = this.convertValueToPosition(0);
            const clampedZeroX = Phaser.Math.Clamp(zeroX, slideLeftX, slideRightX);
            this.track.clear();
            this.track.lineStyle(sliderConfig.track.lineThickness, sliderConfig.track.lineTint);
            this.track.beginPath();
            this.track.moveTo(clampedZeroX, y);
            this.track.lineTo(handleX, y);
            this.track.strokePath();
        }
    }

    calculateInitialPosition(startValue = this.config.startVal) {
        const { slideLeftX, slideRightX } = this.handleConfig;
        const { minVal, maxVal } = this.config;
        const range = maxVal - minVal;
        const sliderRange = slideRightX - slideLeftX;
        const valueRatio = (startValue - minVal) / range;
        return slideLeftX + valueRatio * sliderRange;
    }

    addDragBehavior() {
        this.scene.input.setDraggable(this.handle);
        this.handle.on('drag', (pointer, dragX) => {

            dragX = Phaser.Math.Clamp(dragX, this.handleConfig.slideLeftX, this.handleConfig.slideRightX);

            this.handle.x = dragX;
            this.updateTrack();

            const newValue = this.calculateValue();
            
            // Use the mapping to correctly update the values object
            const mappedKey = valueKeysMapping[this.name];
            values[mappedKey] = newValue;

            visualization.updateOnSliderDrag(mappedKey);
        });
    }

    calculateValue() {
        const { slideLeftX, slideRightX } = this.handleConfig;
        const { minVal, maxVal } = this.config;
        const range = maxVal - minVal;
        const sliderRange = slideRightX - slideLeftX;
        const valueRatio = (this.handle.x - slideLeftX) / sliderRange;
        return minVal + valueRatio * range;
    }

    convertValueToPosition(value) {
        const { minVal, maxVal } = this.config;
        const { slideLeftX, slideRightX } = this.handleConfig;
        const range = maxVal - minVal;
        const sliderRange = slideRightX - slideLeftX;
        const valueRatio = (value - minVal) / range;
        return slideLeftX + valueRatio * sliderRange;
    }

    // New Method: Set the slider to a specific value
    setValue(value) {
        // Convert the value to a position on the slider track
        const position = this.convertValueToPosition(value);
        // Update the handle's x position to match the value
        this.handle.x = Phaser.Math.Clamp(position, this.handleConfig.slideLeftX, this.handleConfig.slideRightX);
        // Update the track to match the new handle position
        this.updateTrack();
    }
}

class UI {
    constructor(scene) {
        this.scene = scene;
        this.config = uiConfig;
        this.playPauseButton = null; // To store the play/pause button
        this.resetButton = null;     // To store the reset button
        this.switches = {};
        this.switchLabels = {}; // Store switch label texts
    }

    create() {
        // Create play/pause and reset buttons
        this.createPlayPauseButton();
        this.updatePlayPauseButton();

        this.createSwitch('showIValue', switchConfig.i);
        this.createSwitch('showRValue', switchConfig.r);
    }

    createPlayPauseButton() {
        // Initially create the play button
        this.playPauseButton = this.scene.add.image(this.config.playControls.playPause.x, this.config.playControls.playPause.y, 'playBtn-img');
        this.playPauseButton.setOrigin(this.config.playControls.playPause.originX, this.config.playControls.playPause.originY);
        this.playPauseButton.setInteractive({ useHandCursor: true });
        this.playPauseButton.setDepth(this.config.playControls.depth);

        this.playPauseButton.on('pointerdown', () => {
            if (!playing) {
                this.play();  // Switch to play
                playing = true;
            } else {
                this.pause();  // Switch to pause
                playing = false;
            }
        });
    }

    play() {
        playing = true;
        this.updatePlayPauseButton();  // Update the button to show the pause image
        // Add code here to start/resume the simulation if needed
    }

    pause() {
        playing = false;
        this.updatePlayPauseButton();  // Update the button to show the play image
        // Add code here to pause the simulation if needed
    }

    updatePlayPauseButton() {
        // Change the button image based on the current play status
        if (playing) {
            this.playPauseButton.setTexture('pauseBtn-img');
        } else {
            this.playPauseButton.setTexture('playBtn-img');
        }
    }

    createSwitch(key, config) {
        // Determine initial state image
        const initialState = config.startState === 'on' ? 'switchOn-img' : 'switchOff-img';
        
        // Create the switch image with hand cursor
        const switchImage = this.scene.add.image(switchConfig.x, config.y, initialState)
            .setScale(switchConfig.scale)
            .setOrigin(switchConfig.originX, switchConfig.originY)
            .setInteractive({ cursor: 'pointer' });

        // Store the switch state and image
        this.switches[key] = {
            state: config.startState,
            image: switchImage
        };

        // Add the toggle functionality
        switchImage.on('pointerdown', () => {
            this.toggleSwitch(key);
        });

        // Add the label text for the switch
        const switchLabel = this.scene.add.text(
            switchConfig.x - switchConfig.textPositionLeftOfSwitch,
            config.y,
            config.words,
            {
                font: `${switchConfig.textSize}px ${switchConfig.font}`,
                fill: Phaser.Display.Color.HexStringToColor(switchConfig.textTint).rgba,
            }
        ).setOrigin(1, 0.5); // Align text to the left of the switch

        this.switchLabels[key] = switchLabel; // Store label text for toggling visibility
    }

    toggleSwitch(key) {
        const switchData = this.switches[key];

        // Toggle the state
        switchData.state = switchData.state === 'on' ? 'off' : 'on';

        // Update the switch image
        const newStateImage = switchData.state === 'on' ? 'switchOn-img' : 'switchOff-img';
        switchData.image.setTexture(newStateImage);

        // Update the global state variables and call the appropriate method on Visualization
        if (key === 'showIValue') {
            showValues.i = switchData.state === 'on'; // Update global variable
            visualization.toggleShowAngleValue(); // Notify Visualization
        } else if (key === 'showRValue') {
            showValues.r = switchData.state === 'on'; // Update global variable
            visualization.toggleShowAngleValue(); // Notify Visualization
        }
    }

    // Method to toggle visibility of the switches and their labels
    toggleSwitchVisibility(visible) {
        Object.keys(this.switches).forEach(key => {
            this.switches[key].image.setVisible(visible); // Toggle switch image
            this.switchLabels[key].setVisible(visible); // Toggle label text
        });
    }

    // Method to toggle visibility of the play/pause button
    togglePlayPauseVisibility(visible) {
        if (this.playPauseButton) {
            this.playPauseButton.setVisible(visible);
        }
    }
}

function preload() {
    // Load backgrounds
    this.load.image('ray-bg', 'ray_bg.PNG'); // upper case png is important for infinityfree
    this.load.image('wavefront-bg', 'wavefront_bg.PNG');
    this.load.image('geometry-bg', 'geometry_bg.PNG');

    // Load slider handle images
    this.load.image('handle', 'handle.png');

    // Load ui images
    this.load.image('playBtn-img', 'playBtn_img.png');
    this.load.image('pauseBtn-img', 'pauseBtn_img.png');

    // Load on and off images for slide switches
    this.load.image('switchOn-img', 'switchOn_img.png');
    this.load.image('switchOff-img', 'switchOff_img.png');

    // Load visualization images
    this.load.image('waveFront-img', 'waveFront_img.png');
    this.load.image('normal-img', 'normal_img.png');
    this.load.image('arrowPink-img', 'arrowPink_img.png');

    // Load geometry images
    this.load.image('tEqualsHsiniOverCText-img', 'tEqualsHsiniOverCText_img.png');
    this.load.image('hText-img', 'hText_img.png');
    this.load.image('tEqualsHsiniOverCOverNText-img', 'tEqualsHsiniOverCOverNText_img.png');

    this.load.image('iDullText-img', 'iDullText_img.png');
    this.load.image('rDullText-img', 'rDullText_img.png');
    this.load.image('iBrightText-img', 'iBrightText_img.png');
    this.load.image('rBrightText-img', 'rBrightText_img.png');

    // Radio button images
    this.load.image('radioButtonSelected-img', 'radioButtonSelected_img.png');
    this.load.image('radioButtonUnselected-img', 'radioButtonUnselected_img.png');

    // Load sliders
    let sliderNames = Object.keys(sliderConfig.sliders);
    sliderNames.forEach(name => {
        let slider = new Slider(this, name);
        sliders.push(slider);
    });
}

function create() {

    // Create backgrounds
    rayBackground = new CustomImage(this, 'ray-bg', bgConfig);
    rayBackground.create();

    wavefrontBackground = new CustomImage(this, 'wavefront-bg', bgConfig);
    wavefrontBackground.create();

    geometryBackground = new CustomImage(this, 'geometry-bg', bgConfig);
    geometryBackground.create();

    //let testObject = new Test(this, 100, 100); // Starting position (100, 100)
    //testObject.create();

    // Create sliders
    sliders.forEach(slider => slider.create());

    rays = new Rays(this);
    wavefronts = new Wavefronts(this);

    ui = new UI(this);
    ui.create();

    // Instantiate and create the first radio button group
    const radioGroup1 = new RadioButtonGroup(this, radioButtonGroups, 'group1'); //visualizationChoice
    radioGroup1.create();

    geometry = new Geometry(this);

    angles = new Angles(this);

    visualization = new Visualization(this);
    visualization.create();
    visualization.changeVisualization();
}

function update() {

    if (playing) {
        visualization.updateOnTick();
    }
}
</script>
